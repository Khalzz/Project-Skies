use std::collections::HashMap;
use std::sync::mpsc::Sender;

use crate::gameplay::plane::plane::{Plane, PlaneControls};
use crate::gameplay::wing::{Wing};
use crate::gameplay::airfoil::AirFoil;
use crate::gameplay::wheel::{Wheel, WheelData};
use crate::physics::physics::DebugPhysicsMessageType;
use crate::physics::physics_handler::{MetadataType, PhysicsData};
use crate::primitive::manual_vertex::ManualVertex;
use rapier3d::prelude::{ColliderSet, QueryPipeline, RigidBodySet};
use nalgebra::{vector};
use nalgebra::Vector3;

pub struct PlanePhysicsLogic {
    pub wheels: Vec<Wheel>,
    pub wings: Vec<Wing>,
    pub renderizable_wheels: HashMap<String, WheelData>,
    pub renderizable_lines: Vec<DebugPhysicsMessageType>,
    pub previous_aileron_input: f32,
    pub roll_damping_factor: f32,
    pub roll_stability_factor: f32,
    pub max_roll_velocity: f32,
}

impl PlanePhysicsLogic {
    pub fn new() -> Self {
        let wheels = vec![
            Wheel::new("wheel-f".to_string(), vector![0.0, 0.0, 10.0], 5.0, 100000.0, 100000.0),
            Wheel::new("wheel-lb".to_string(), vector![-3.0, 0.0, 0.0], 5.0, 100000.0, 100000.0),
            Wheel::new("wheel-rb".to_string(), vector![3.0, 0.0, 0.0], 5.0, 100000.0, 100000.0)
        ];

        // load airfoil:
        let naca_2412 = AirFoil::new("assets/aero_data/f16.ron".to_owned());
        let naca_0012 = AirFoil::new("assets/aero_data/f16-elevators.ron".to_owned());

        // i have to also add left and right ailerons
        let wings = vec![
            Wing::new(vector![8.5, 0.0, 1.0], 6.96, 2.50, 0.0, naca_2412.clone(), vector![0.0, 1.0, 0.0], 0.5, true), // left wing
            Wing::new(vector![-8.5, 0.0, 1.0], 6.96, 2.50, 0.0, naca_2412.clone(), vector![0.0, 1.0, 0.0], 0.5, true), // right wing
            Wing::new(vector![0.0, 0.0, -6.0], 6.54, 2.70, 0.0, naca_0012.clone(), vector![0.0, 1.0, 0.0], 1.0, false), // elevator wing
            Wing::new(vector![0.0, 5.0, -7.0], 6.96, 2.50, 0.0, naca_0012.clone(), vector![1.0, 0.0, 0.0], 0.5, false) // rudder wing
        ];

        Self { wheels, wings, renderizable_wheels: HashMap::new(), renderizable_lines: Vec::new(), previous_aileron_input: 0.0, roll_damping_factor: 0.05, roll_stability_factor: 0.0, max_roll_velocity: 0.0 }
    }

    /// Configure roll damping for different aircraft types
    pub fn update(&mut self, plane_controls: &PlaneControls, collider_set: &ColliderSet, rigidbody_set: &mut RigidBodySet, query_pipeline: &QueryPipeline, physics_data: &mut PhysicsData, debug_physics_tx: &Sender<Vec<DebugPhysicsMessageType>>) {
        self.renderizable_lines.clear();
        
        if let Some(rigidbody) = rigidbody_set.get_mut(physics_data.rigidbody_handle) {
            // Apply damping to slow down the object naturally
            //rigidbody.set_linear_damping(0.05); // Linear velocity damping
            //rigidbody.set_angular_damping(0.05); // Angular velocity damping
            
            // Reset forces and torques at the beginning of each frame
            // This prevents accumulation of forces from previous frames
            rigidbody.reset_forces(true);
            rigidbody.reset_torques(true);

            // Throttle force (forward thrust) - transform to world space
            let max_thrust = 60000.0; // newtons of force generated by engine
            let power_value_world = rigidbody.rotation() * nalgebra::Vector3::new(0.0, 0.0, max_thrust * plane_controls.throttle);

            // Apply the thrust force to the rigidbody.
            rigidbody.add_force(power_value_world, true);
            // Thrust

            self.wings[0].control_input = plane_controls.aileron;
            self.wings[1].control_input = -plane_controls.aileron;
            self.wings[2].control_input = -plane_controls.elevator;
            self.wings[3].control_input = plane_controls.rudder;
            
            for wing in &mut self.wings {
                wing.physics_force(rigidbody, &mut self.renderizable_lines);
            }
        }

        self.renderizable_wheels.clear();
        
        for (index, wheel) in self.wheels.iter_mut().enumerate() {
            if let Some((suspension_force, suspension_origin, wheel_position)) = wheel.update_wheel(&physics_data, &collider_set, rigidbody_set, &query_pipeline) {
                self.renderizable_wheels.insert(wheel.mesh_name.clone(), WheelData { wheel_position: wheel_position });
                self.renderizable_lines.push(DebugPhysicsMessageType::RenderizableLines([ManualVertex { position: [suspension_origin.x, suspension_origin.y, suspension_origin.z], color: [0.0, 1.0, 0.0] }, ManualVertex { position: [wheel_position.x, wheel_position.y, wheel_position.z], color: [0.0, 1.0, 0.0] }]));
                
                if let Some(rigidbody) = rigidbody_set.get_mut(physics_data.rigidbody_handle) {
                    rigidbody.add_force_at_point(suspension_force, suspension_origin.into(), true);
                }
            }
        }

        physics_data.metadata.insert("wheels".to_string(), MetadataType::Wheels(self.renderizable_wheels.clone()));        
    }
}